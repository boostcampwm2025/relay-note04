# AI 활용 능력 비교 실험: "내 상황에 최적화된 AI 찾기"

## 📋 퀘스트 배경

현재 일상적으로 AI를 활용하는 상황은 크게 **4가지 영역**으로 나뉩니다:

1. **창작/표현** (이미지, 아이디어 생성)
2. **소통/상담** (고민 해결, 조언 구하기)
3. **학습/평가** (체크포인트, 피드백)
4. **지식/이해** (개념 설명, 학습 가이드)

각 AI는 이런 상황별로 서로 다른 강점을 보입니다. 어떤 AI는 창의적 아이디어에 강하고, 어떤 AI는 논리적 설명에 뛰어나며, 또 다른 AI는 공감적 상담에 특화되어 있습니다.

### 🎯 목적

**"상황별로 나에게 가장 도움이 되는 AI는 누구인가?"**

단순히 "어떤 AI가 더 좋나?"를 묻는 것이 아니라, **내가 처한 상황과 필요에 따라 어떤 AI를 선택해야 효과적인지**를 여러 AI 경험을 통해 발견하는 것입니다.

## Ⓜ️ 퀘스트 1: 오늘의 기분 이미지 생성 비교하기

### 목표 : 오늘의 기분을 기반으로 다양한 AI의 이미지 생성 도구를 이용하여 이미지를 생성하고, 결과물을 비교하여 각 도구의 스타일 차이를 경험한다.

### 미션 요구사항

- 오늘의 기분을 표현하는 문장 작성
- 최소 2개 이상의 AI 이미지 생성 도구를 사용하여 이미지 생성
- 원하는 이미지 선택하여 슬랙이나 줌으로 공유하기

### 명령 프롬프트 예시

`오늘은 금요일이여서 너무 기분이 좋아` 이 기분을 나타내는 이미지 생성해줘.

### 출력 예시

<img width="512" height="512" alt="Image20250725144153" src="https://github.com/user-attachments/assets/d9b778be-7d3d-4eb9-9d90-a8b28604e82d" />

## Ⓜ️ 퀘스트 2: AI 고민 상담

### 목표: 여러 AI의 상담 스타일을 비교해보고, 나와 가장 잘 통하는 AI 상담사 찾기

### 미션 요구사항

- 3개의 AI 선정하기
- AI 상담 평가 기준 만들기(ex- 조언이 현실적인가?, 말투/톤 만족도 등)
- 각각의 AI에게 똑같은 고민 질문하기
- 응답 비교 후 마음에 드는 AI 선택하기

### 명령 프롬프트 예시

`고민이 있어. 해야 할 일은 많은데 자꾸 미루게 돼. 어떻게 하면 좋을까?`

### 출력 예시

**chatGPT**

```
고민을 나눠줘서 고마워. 일을 미루게 되는 건 누구에게나 일어나는 일이지만, 그 이유와 해결책은 사람마다 조금씩 달라. 아래에 몇 가지 접근 방식을 제안해 볼게:

1. 해야 할 일의 정체를 파악해 봐
정말 해야 하는 일인가?: 남이 시켜서 하려는 건 아닌지, 내게 정말 필요한 일인지 점검해봐.

막연하게 느껴지진 않나?: 구체적인 행동으로 쪼개보면 실행하기 쉬워져.

예: “리포트 작성” → “자료 3개 찾기” → “개요 쓰기” → “첫 단락 쓰기”

2. 감정도 정리해 봐
“하기 싫다”는 감정 속에는 불안, 부담, 지루함, 피로 같은 감정이 숨어 있을 수 있어.

그 감정을 인정하고, ‘이 감정을 느끼는 나’를 있는 그대로 받아들이는 것이 시작이야.

3. 작은 성공 루틴 만들기
5분만 하자: 시작의 부담을 줄이면 뇌도 따라와 줘.

끝나면 보상 주기: 작은 성취 뒤엔 좋아하는 간식, 유튜브 10분 보기 등 보상을 줘도 좋아.

환경 제어: 폰은 멀리, 알림 끄기, 작업에 집중할 수 있는 공간 만들기.

4. ‘완벽해야 해’라는 생각 내려놓기
자꾸 미루는 사람 중엔 “완벽하게 하려는” 사람이 많아.

일단 대충이라도 해놓으면 수정은 나중에 가능해. 초안은 못나도 괜찮아.

마지막으로…
“미룬다고 내가 나쁜 사람은 아니야.”
지금 이 질문을 하는 너는 이미 ‘시작하려는 중’이야.
그 마음을 소중히 여겨줘.

혹시 너만의 미루는 습관이나 상황이 있다면 더 자세히 얘기해줘. 맞춤형으로 도와줄게!
```

**Copilot**

```
누구나 그런 순간 있잖아. 해야 할 건 쌓여 있는데 이상하게 손은 안 가고… 마음은 조급한데 몸은 멈춰버리는 느낌. 너무 자연스러운 일이야, 자기 자신을 탓하지 않았으면 좋겠어. 😊
그럼에도 불구하고 조금씩 움직이기 위한 팁을 몇 가지 건네볼게:

💡 미루는 습관을 깨는 작은 전략들
- 작게 시작하기
"5분만 한다"는 마음으로 시작하면 부담이 확 줄어. 막상 시작하면 흐름을 타게 되는 경우가 많아.

- 할 일을 구체적으로 쪼개기
"과제 끝내기"보단 "자료 찾기 → 개요 작성 → 첫 문단 쓰기"처럼 세분화하면 명확해지고 접근도 쉬워져.

- 시각적인 리스트 만들기
할 일들을 포스트잇이나 앱에 써서 눈에 보이게 만들면 생각만 하는 것보다 훨씬 실행에 옮기기 좋아.

- 보상 설정하기
"이거 끝나면 좋아하는 디저트 먹기" 같은 작은 보상이 동기부여가 되기도 해. 🍰

- 자기 자신과 대화하기
"왜 지금 이걸 미루는 걸까?" 잠깐 생각해보면 숨겨진 불안이나 부담을 발견할 수도 있어. 그럼 해결의 실마리가 더 가까워져.

혹시 요즘 어떤 일 때문에 특히 미루게 되는 걸까? 더 구체적으로 나눠줘도 좋고, 아니면 그냥 편하게 털어놔도 괜찮아. 나 여기 있어. 🙌
```

**Gemini**

```
"해야 할 일은 많은데 자꾸 미루게 된다"는 고민, 정말 많은 분들이 공감하는 어려움이에요. 저도 비슷한 경험을 자주 합니다. 이런 상황에서 도움이 될 만한 몇 가지 방법을 알려드릴게요.

1. 목표를 작게 나누고 시작하기
너무 거대한 목표는 시작조차 어렵게 만들어요. 큰일을 여러 개의 작은 단계로 나누면 훨씬 부담이 줄어들고, 각 단계를 완료할 때마다 성취감을 느낄 수 있어 다음 단계로 나아가는 동기가 됩니다.

예시: "보고서 작성" 대신 "보고서 개요 작성", "자료 조사", "초고 작성" 등으로 나누는 거죠.

2. 시간 관리 기법 활용하기
시간 관리 기법들은 업무에 집중하고 미루는 습관을 개선하는 데 효과적이에요.

뽀모도로 기법: 25분간 집중해서 일하고 5분 휴식하는 것을 반복하는 방법이에요. 짧은 집중 시간 동안 몰입하고, 휴식으로 재충전해서 피로감을 줄일 수 있습니다.

아이젠하워 매트릭스: 할 일을 중요하고 긴급한 일, 중요하지만 긴급하지 않은 일, 긴급하지만 중요하지 않은 일, 긴급하지도 중요하지도 않은 일로 나누어 우선순위를 정하는 방법이에요. 미루는 습관의 원인 중 하나가 무엇을 먼저 해야 할지 모르는 경우인데, 이 매트릭스를 활용하면 명확한 우선순위를 가질 수 있습니다.

3. '시작하기'에 집중하기
가장 어려운 건 '시작'이에요. 일단 시작하면 생각보다 일이 술술 풀리는 경우가 많습니다. "딱 5분만 해보자" 또는 "단 한 문장만 써보자" 같은 마음으로 가볍게 시작해보세요. 일단 시작하고 나면 관성 때문에라도 계속 이어갈 가능성이 높아집니다.

4. 방해 요인 제거하기
스마트폰, 인터넷, TV 등은 미루기의 주범이 될 수 있어요. 일을 시작하기 전에 방해될 만한 요소들을 미리 치워두거나, 알림을 끄거나, 아예 다른 공간에서 작업하는 것도 좋은 방법입니다.

5. 보상 체계 만들기
작은 목표를 달성할 때마다 자신에게 작은 보상을 주세요. 좋아하는 커피 한 잔, 짧은 휴식, 재미있는 영상 시청 등 자신이 좋아하는 것을 보상으로 설정하면 동기 부여에 큰 도움이 됩니다.

6. 완벽주의 내려놓기
"완벽하게 해야 해"라는 압박감 때문에 오히려 시작을 못 하는 경우가 많아요. 처음부터 완벽하려 하기보다, 일단 '완성'하는 것에 초점을 맞추고 나중에 수정하거나 보완하는 것을 목표로 해보세요. '일단 끝내기'가 '완벽하게 하기'보다 중요할 때가 많습니다.

7. 운동 및 건강 관리
신체적인 건강은 정신적인 에너지와 직결됩니다. 규칙적인 운동과 충분한 수면, 균형 잡힌 식사는 업무 효율을 높이고 무기력감을 줄이는 데 큰 도움이 됩니다.

어떤 방법이든 자신에게 맞는 것을 찾아 꾸준히 실천하는 것이 중요해요. 혹시 이 중에서 가장 먼저 시도해보고 싶은 방법이 있으신가요?
```

## Ⓜ️ 퀘스트 3: AI 활용 체크포인트 생성

### 목표: AI를 활용해 미션 수행하기 전 학습해야 할 사전지식들을 체크리스트로 생성할 수 있다. 이를 통해 필요한 지식과 준비 과정을 사전에 파악하고, 학습 계획을 보완한다.

### 미션 요구사항

- **미션 설명 입력**

  - 예: “함수형 프로그래밍으로 불변성 연결리스트와 해시맵 구현”

- **AI 호출**

  - 주어진 미션을 해결하기 위해 필요한 선행 지식/기술 목록 요청

- **체크포인트 생성**

  - AI가 제안한 학습 포인트를 체크리스트 형태로 출력

- **결과 활용**
  - 출력된 체크리스트를 개인 학습 계획에 반영
  - 필요 시 사용자 체크포인트와 비교

### 명령 프롬프트 예시

```
[주어진 미션]의 정보를 넘겨주고, 내가 진행해야 될 미션인데 이걸 해결하기 위해서 학습해야 될 사전지식들을 체크리스트로 만들어줘
```

### 출력 예시

```
=== 미션 ===
함수형 프로그래밍으로 불변성 연결리스트와 해시맵 구현

=== AI 학습 체크리스트 ===

1. 함수형 프로그래밍 개념
2. 불변성(Immutable) 데이터 구조 이해
3. 참조 투명성(Referential Transparency)
4. Kotlin 데이터 클래스와 copy() 활용법
5. 고차함수(map, filter, reduce) 사용법
6. 연결리스트 기본 구조와 노드 개념
7. 해시맵의 해싱 알고리즘 기초
8. 테스트 코드 작성(JUnit 또는 Kotest)

=== 활용 방법 ===

- 위 항목 중 모르는 개념은 먼저 학습 후 미션 수행
- 본인 체크포인트와 비교하여 빠진 부분 보완
```

## Ⓜ️ 퀘스트 4: AI 설명 스타일 선호도 비교하기

### 목표: 각 AI의 설명 스타일이 나의 학습 스타일과 얼마나 맞는지 평가

### 미션 요구사항

- 동일한 개념을 각 AI(Chatgpt, Gemini, Claude)에게 설명 요청
- 각 AI의 설명을 읽은 후 각 설명의 특징과 이해도를 1-10점으로 평가
- 어떤 스타일(간결함, 상세함, 예시 중심, 이론 중심 등)이 본인에게 맞는지 분석

### 명령 프롬프트 예시

```
Publisher-Subscriber 패턴에 대해 설명해줘
```

### 결과 예시

| 구분              | ChatGPT            | Claude             | Gemini                    |
| ----------------- | ------------------ | ------------------ | ------------------------- |
| **응답 길이**     | 중간 (500자)       | 짧음 (300자)       | 김 (800자)                |
| **설명 구조**     | 정의 → 예시 → 활용 | 개념 → 특징 → 예시 | 정의 → 원리 → 예시 → 심화 |
| **예시 품질**     | 실용적, 다양함     | 간단명료           | 상세하고 체계적           |
| **전문 용어**     | 적절히 사용        | 최소화             | 자세히 설명               |
| **이해도 (1-10)** | 8점                | 6점                | 9점                       |

**ChatGPT 특징:**

- ✅ 실무 중심의 예시 제공
- ✅ 단계별 설명이 논리적
- ❌ 가끔 너무 일반적인 설명

**Claude 특징:**

- ✅ 핵심만 간결하게 전달
- ✅ 불필요한 정보 없음
- ❌ 초보자에게는 설명 부족

**Gemini 특징:**

- ✅ 매우 상세하고 체계적
- ✅ 다양한 관점에서 설명
- ❌ 정보가 너무 많아 핵심 파악 어려움

**나의 학습 스타일:** 예시 중심, 중간 수준의 상세함 선호

**최적의 AI:** Gemini (9점)

- **선택 이유:** 개념의 원리부터 응용까지 체계적으로 설명해줘서 깊이 있는 이해 가능
- **아쉬운 점:** 가끔 너무 많은 정보로 인해 집중력 분산

---

WEEK2 퀘스트 선택 및 수행 결과

### J064 김재민 🤿

#### 수락한 퀘스트 -> 퀘스트 3: AI 활용 체크포인트 생성 (완료 ✅)

<details>
<summary>🚀수행한 퀘스트 펼쳐 보기/닫기</summary>
<div markdown="1">

Day12의 미션 달성을 위한 cs 체크리스트 작성을 도와달라고 한 결과입니다.

1. javascript

- 모듈 시스템 (require, module.exports)
- 클래스 (class, constructor, extends)

[ ] 비동기 프로그래밍의 이해:

- 이벤트 루프(Event Loop)의 기본 동작 방식: Node.js가 단일 스레드에서 어떻게 비동기 작업을 처리하는지 (콜 스택, 이벤트 큐, 마이크로태스크 큐, 페이즈).
- 관련 아티팩트: nodejs_event_loop_practice_2
- 논 블로킹(Non-blocking) I/O: 메인 스레드가 작업을 기다리지 않고 다른 작업을 계속하는 개념.
- 콜백(Callback): 비동기 작업이 완료된 후 실행될 함수.

[ ] Promise의 이해와 활용:

- Promise의 3가지 상태 (pending, fulfilled, rejected).
- .then(), .catch()를 이용한 Promise 체이닝 및 에러 처리.
- Promise.all(), Promise.race()를 이용한 병렬 비동기 작업 처리.
- 관련 아티팩트: queue_scheduling_nodejs (Promise 역할 분담 섹션)

[ ] async/await의 이해와 활용:

- Promise 기반 코드를 동기 코드처럼 읽기 쉽게 만드는 문법적 설탕.
- async 함수 선언 및 await 키워드 사용법.
- try...catch를 이용한 async/await 에러 처리.
- 관련 아티팩트: promise_to_async_await_conversion

[ ] EventEmitter의 이해와 활용:

- EventEmitter의 역할 (발행-구독 패턴).
- on(), emit() 메서드를 이용한 이벤트 구독 및 발행.
- 모듈 간 느슨한 결합을 위한 통신 수단으로서의 활용.
- 관련 아티팩트: event_bus, queue_scheduling_nodejs (EventEmitter 역할 분담 섹션)

2. 데이터 구조 및 설계 원칙

[ ] 큐(Queue) 자료구조:

- FIFO(First-In, First-Out) 원칙 이해.
- enqueue (데이터 추가), dequeue (데이터 제거), isEmpty (비어있는지 확인) 등 기본 연산 이해.
- 관련 아티팩트: queue_scheduling_nodejs (큐 구현 방식 섹션)
- Producer ↔︎ Consumer 관계에서 큐의 역할 및 발생 가능한 문제점 (속도 불균형, 오버플로우/언더플로우)과 해결 방식.
- 관련 아티팩트: producer_consumer_problem

[ ] Map 객체:

- 키-값 쌍을 저장하는 컬렉션으로, 객체보다 유연하게 키를 사용할 수 있다는 점 이해. (예: videoId를 키로 하여 영상 상태 관리)

[ ] 객체 지향 프로그래밍 (OOP) 기본:

- 클래스, 객체, 인스턴스 개념.
- 캡슐화, 상속, 다형성 (간단한 수준).
- 의존성 역전 원칙 (DIP): 추상화에 의존하고 구체적인 구현에 의존하지 않는다는 개념.
- 관련 아티팩트: dependency_inversion_principle
- 의존성 주입 (DI): 외부에서 필요한 의존성을 전달받는 방식.

[ ] 함수형 프로그래밍 (FP) 기본 개념:

- 순수 함수(Pure Functions): 동일 입력 -> 동일 출력, 부수 효과 없음.
- 불변성(Immutability): 데이터 직접 변경 대신 새로운 사본 생성.
- 고차 함수(Higher-Order Functions): 함수를 인자로 받거나 반환하는 함수 (map, filter, reduce 등).
- 관련 아티팩트: functional_programming_js

3. 테스트 및 디버깅

[ ] 단위 테스트의 중요성:

- 단위 테스트가 왜 필요한지, 어떤 이점을 주는지 이해.
- 테스트하기 쉬운 코드의 특징.
- 관련 아티팩트: testable_code_guide

[ ] Jest 또는 Mocha/Chai 사용법:

- 선택한 테스트 프레임워크의 설치 및 기본 사용법.
- 테스트 스위트/테스트 케이스 작성 방법.
- 어설션(Assertion) 사용법 (expect().toBe(), assert.equal() 등).
- 모킹(Mocking)의 개념과 필요성: 외부 의존성을 가짜로 대체하는 이유.
- jest.fn(), jest.mock(), jest.spyOn() 또는 Mocha의 sinon과 같은 라이브러리를 통한 모킹/스텁핑.
- 관련 아티팩트: jest_mocking_guide
- 시간 기반 비동기 함수(setTimeout)를 테스트하기 위한 시간 모킹 방법.

[ ] 비동기 코드 디버깅 방법:

- console.log를 이용한 흐름 추적.
- Node.js 디버거 또는 IDE(VS Code) 통합 디버거 사용법.
- try...catch를 이용한 에러 핸들링.
- 관련 아티팩트: async_debugging_guide

이 체크리스트는 미션의 복잡성을 고려했을 때, 성공적인 구현과 테스트를 위해 필요한 핵심적인 개념들을 담고 있습니다. 각 항목을 이해하고 적용하려 노력한다면 미션 목표 달성에 큰 도움이 될 것입니다.

### 느낀점

> 확실히 ai가 짜주니까, 기초부터(내가 알고있는 것 까지) 설계해주는 것을 느꼈다. 그래서 더 0부터 100까지 차근차근 cs지식을 확실히 알 수 있을 것 같다.

</div>
</details>

### 박혜린

- 수행할 퀘스트: AI 활용 체크포인트 생성
- 선택 이유: 체크 포인트를 작성할 때 세부적으로 나누는게 어렵다고 느꼈었는데 AI이 도움을 받아서 내가 쓴 체크 포인트와 어떤 점이 다른지를 공부해서 과업을 체계적으로 세분화하는 것을 배우고 싶기 때문이다.

- **수행 결과**
- 체크포인트가 기능 설명서처럼 구현 흐름과 사용 의도가 잘 드러나고 체크포인트만 읽어도 미션 구현이 가능할 만큼 자세히 기록하고 싶었다.
- 처음부터 AI로 체크포인트를 작성하게 하지는 않고 내가 스스로 작성해본 다음에 AI에게 체크포인트 작성을 부탁하고 내가 쓴 것과 비교했다.
- 또 미션을 어느정도 해결한 다음에 내가 구현한 코드의 결과를 보여주면서 체크포인트를 좀 더 자세히 적을 만한 부분이 없을지 물어보았다.
- 가장 큰 도움을 받은 부분은 모듈별로 필요한 함수를 구현하는 순서를 보기 좋기 정리한 점이다. 내가 스스로 적은 것보다 훨씬 체계적이고 이해하기에도 좋았다.
- 각 함수의 목적, 입력, 출력에 따라 정리해주어서 체크포인트로서 잘 정리되기도 하고 체크포인트만 보고도 미션 수행이 가능할 만큼 자세한 체크포인트를 적고 싶다는 나의 개인적인 목표도 성취할 수 있었다.
- 실제 내 체크포인트에서 사용된 함수 설명 부분의 일부이다.
  ```md
  #### ✅ 핵심 유틸리티 함수들 구현하기
  - ✅ GIT_DIR 상수
      - 목적: Git 디렉터리 이름(.git)을 하드코딩하지 않고 일관되게 사용하기 위한 상수입니다.
      - 입력: 없음 (상수)
      - 출력: 문자열 '.git'
  
  - ✅ isGitRepository() 함수
      - 목적: 현재 프로그램이 실행되는 위치에 .git 디렉터리가 있는지 확인하여 Git 저장소인지 판별합니다.
      - 입력: 없음
      - 출력: boolean. .git 디렉터리가 존재하면 true, 그렇지 않으면 false.
  
  - ✅ getObjectPath(sha) 함수
      - 목적: Git 개체(object)의 SHA-1 해시 값을 받아 실제 파일 시스템에 저장된 경로를 계산하여 반환합니다.
      - 입력: sha (string): 40자의 Git 개체 SHA-1 해시 값 (예: 'e9d71f2aa...e98')
      -출력: string. 계산된 파일 경로 (예: .git/objects/e9/d71f2aa...e98) 또는 sha가 유효하지 않으면 null.
  
  - ✅ hashBlob(fileContent) 함수
      - 목적: 파일의 원본 내용을 받아 Git이 내부적으로 blob 개체를 저장할 때 사용하는 방식과 동일하게 SHA-1 해시를 계산합니다.
      - 입력: fileContent (Buffer): fs.readFileSync 등으로 읽어온 파일의 원본 데이터.
      - 출력: string. "blob [크기]\0[내용]" 형식으로 조합된 데이터의 40자 SHA-1 해시 값.
  ```

  ### 느낀점
  - 내가 작성한 체크포인트와 AI가 작성한 체크포인트를 비교하면서 느낀점: 우선 둘을 비교하는 과정에서 미션의 요구사항 중에 모호한 것이 있었다면 다시 한번 고민하게 되었다. 이 점에서 미션을
    한 층 더 깊이 이해할 수 있었다고 생각한다. 또 AI에게 체크포인트를 작성해달라고 할 때 단순히 미션을 복사해서 붙여넣는 것보다 어느정도 미션 분석을 정리하고 이번 미션의 목표는 무엇인지를 전달했을 때
    미션의 학습 목표에 적합하면서도 상세한 체크포인트를 받을 수 있었다.  
  - 어느정도 구현한 이후에 체크포인트를 다시 AI에게 요청했던 이유와 느낀점: 나 스스로도 체크포인트만 작성하고 미션을 구현하지 않은 상태에서 AI에게 체크포인트를 받았을 때는 내가 생각하고 있는 미션 해결 방식과 다른 점이 있어 설계와 구현 부분에서의 체크포인트에서는 도움을 받기가 어려웠다. 초반에 내가 작성한 체크포인트와 AI의 것을 비교할 때는 학습 부분에서 도움을 받았다. 내가 어느정도 구현한 다음에 미션 설명과 더불에 지금 내가 이런 방향으로 설계했고 이렇게 구현했을 때의 체크포인트를 작성해달라고 했다. 그러한 과정에서 내가 고민하지 못하고 넘어갔던 부분이다. 또는 내가 구현한 것에 대해 내가 적은 것보다 훨씬 더 가독성 좋고 간결한 체크포인트로 정리되는 점에서 유용했다.  
  - AI에게 도움을 얻고자 하는 부분에 따라 도움을 요청하면서 내가 주어야 할 정보를 생각해보고 AI의 도움이 필요한 단계를 잘 생각해보는 것의 중요성을 느끼게 되었다.  
